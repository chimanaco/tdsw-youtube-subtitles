0:00:00.015,0:00:08.890
[音楽]

0:00:10.180,0:00:15.210
みなさんこんにちは
TDSW YouTubeチャンネルです

0:00:15.210,0:00:23.060
TouchDesignerではじめるGLSLの第8回になります
よろしくお願いします

0:00:23.060,0:00:30.934
今回はですね
ご覧いただいている円をGLSLで描くというのをやっていきます

0:00:30.958,0:00:36.829
TouchDesignerでいうところの
Circle TOPに近い見た目のものを作っていきます

0:00:36.829,0:00:44.290
今回やることですが、まず円形グラデーションを作る
大きさを調整する

0:00:44.290,0:00:51.046
円を塗りつぶす
最後に正規化を行い、描画の比率を保つというのをやっていきます

0:00:51.071,0:00:53.515
それではやっていきましょう

0:00:53.540,0:00:55.929
まずですねいつも通り

0:00:55.954,0:01:03.759
GLSL TOPを配置して
GLSLをエディターで開いています

0:01:04.501,0:01:09.221
最初にGLSLで円形のグラデーションを作っていきます

0:01:09.432,0:01:13.261
まず最初にやる事としていつも通り

0:01:13.286,0:01:23.265
vec2 p = vUV.st
とします

0:01:23.967,0:01:28.852
次にですねlengthという関数を使います

0:01:28.877,0:01:33.860
これで距離をとることができます

0:01:39.650,0:01:42.250
こうですね

0:01:42.400,0:01:51.410
この算出したdをrgbに追加します

0:01:51.435,0:01:52.990
こうなります

0:01:53.015,0:02:01.900
今ですねこの基準点0のところから
グラデーションが円形にできているという形になります

0:02:02.480,0:02:09.510
これを真ん中に持っていきたいので
中心点をずらします

0:02:10.170,0:02:21.100
ここで
vec2 center = vec2(0.5, 0.5)

0:02:21.125,0:02:23.318
こういう風にします

0:02:23.343,0:02:32.546
この値をpから引くと
こうなると真ん中に持ってくることができました

0:02:32.571,0:02:38.310
これがどうなっているか1回TOP toでまた見てみましょう

0:02:42.338,0:02:46.300
rだけ見れればいいので他は消しておきます

0:02:46.300,0:02:49.708
こういう感じになってますね

0:02:49.733,0:02:55.904
0.5があって
0.5から0になってもう1回0.5になっていくと

0:02:55.929,0:02:59.105
こういう形になっています

0:03:01.140,0:03:04.548
続いてこれのサイズを変えていきます

0:03:04.573,0:03:12.188
単純にですねdの値に数をかけてあげると
サイズを変えることができます

0:03:12.213,0:03:18.761
t *= 2とか入れてみると
変わりますね

0:03:18.786,0:03:23.572
もう少しちょっと大きくしてみましょう
するとこんな感じになるんですね

0:03:23.604,0:03:29.905
ここで何が起こっているか
もう一度TOP Toで確認をしたいんですけども

0:03:29.929,0:03:32.289
まずはじめにですね

0:03:32.314,0:03:40.989
GLSLのPixel Formatというのを
16-bit floatにします

0:03:41.020,0:03:43.108
なぜこれをやるかというとですね

0:03:43.133,0:03:49.702
デフォルトではこのFormatが
8-bit fixedっていうのになっているんですね

0:03:49.727,0:03:56.047
この場合どんな値を持っていても
0から1の値が出力されることになるんですけども

0:03:56.072,0:04:02.574
これを16-bitにすると
プラスマイナスのどんな値でも出力ができるようになります

0:04:04.613,0:04:09.998
これを16-bit float
これに変えます

0:04:10.023,0:04:13.670
ここが今変化したのがわかると思うんですけども

0:04:15.882,0:04:23.363
要するに
2から入って0になって2になっている

0:04:23.387,0:04:29.377
0から1までで黒から白のグラデーションが行われるので

0:04:29.402,0:04:32.482
範囲はここからこの真ん中までの位置になりますね

0:04:32.507,0:04:37.217
なのでここの数を大きくする
例えば8とかすると

0:04:37.242,0:04:44.360
ここが4から0で4
とこういう風になっています

0:04:45.440,0:04:51.860
もう1つデバッグの方法として
よくやるものがあるんですけども

0:04:51.884,0:04:55.467
Viewer ActiveをONにして

0:04:55.492,0:05:00.742
Display Pixel Values
これを選択します

0:05:00.767,0:05:05.191
こうするとですね
ちょっと白on白で見にくいんですけども

0:05:05.216,0:05:12.080
これでrの値が4となっているのが見えると思います

0:05:12.080,0:05:20.816
ここで4で だんだんここに向かって0に入ってきて
もう1回4に行くと 数字が分かると思いますね

0:05:21.899,0:05:27.396
これもデバッグにすごい便利なのでぜひ使ってみてください

0:05:27.420,0:05:33.940
では続きまして
今度はこの円を塗りつぶしていきたいと思います

0:05:38.540,0:05:46.009
ここで円を塗りつぶすのにはいろいろやり方があるのですが
今回はその1つをご紹介します

0:05:46.009,0:05:49.889
これ1回戻します
こうしておきます

0:05:49.889,0:05:55.187
でここで使うのがsmoothstepという関数です

0:05:55.211,0:06:10.495
d = smoothstep(0.95, 1, d);

0:06:10.520,0:06:15.120
こんな感じで書いてみると

0:06:15.145,0:06:22.109
塗りつぶしが行われて若干アンチエイリアスもかかってると
こういう風になります

0:06:22.134,0:06:29.298
このsmoothstepというのがどういう関数かというと
これはエルミート補間という やつで

0:06:29.323,0:06:37.145
1つ目の引数より小さい時は0で
2つ目の引数より大きい時は1

0:06:37.961,0:06:46.944
この引数1から引数2の間の時は
滑らかに変化する数値を返してくる

0:06:46.969,0:06:52.851
そういうことになります
なので0.95 この辺ですね

0:06:52.876,0:07:00.571
0.95までの間はゼロで0.95から1の間がスムーズに変化している
グラデーションであると

0:07:01.704,0:07:06.448
残りのところは全部1
とこういう風になっています

0:07:07.940,0:07:11.134
これで円が描けました

0:07:11.509,0:07:16.530
ここで1つ問題がありまして

0:07:16.980,0:07:23.599
これのですね
アスペクト比が変わると

0:07:24.185,0:07:28.479
いわゆる正円でなくなってしまうんですよね

0:07:30.171,0:07:36.564
解像度が変わる度にこれの比率が変わってしまうと
こういう問題があります

0:07:36.589,0:07:41.052
正方形で作業するシーンってそんなにないと思いますし

0:07:41.077,0:07:45.540
いろんな解像度で皆さん作業することになると思うんですけれども

0:07:45.565,0:07:51.250
それに合わせて毎回こう設定を変えていたら
すごい大変ですよね

0:07:51.490,0:07:55.398
解決方法として座標の正規化というものがあります

0:07:55.423,0:08:00.258
正規化を行うコードの1つにこういうものがあります

0:08:00.283,0:08:13.267
 vec2 p =  (gl_FragCoord.xy * 2.0 - uResolution) / min(uResolution.x, uResolution.y);

0:08:13.292,0:08:18.669
シェーダーアートとか言われるものを見ていくと
こういうコードを結構見ると思うんですね

0:08:18.694,0:08:24.649
これは何をやっているかと言うと
短い辺の長さで正規化をするということをやっています

0:08:25.930,0:08:33.807
僕も最初理解するのに結構時間がかかってしまったので
慣れてない人はちょっと難しいと思うんですけれども

0:08:34.320,0:08:36.650
これを説明していこうと思います

0:08:36.675,0:08:40.580
順を追って説明してみたいと思います

0:08:40.605,0:08:46.880
横幅が1000で縦が500
というのがあったとします

0:08:46.880,0:08:59.246
 vec2 p =  (gl_FragCoord.xy * 2.0 - uResolution) / min(uResolution.x,
uResolution.y);

0:08:59.271,0:09:03.537
こういうコードですね
これを一個一個説明していきます

0:09:03.562,0:09:08.310
まずですね
gl_FragCoord.xyというやつなんですけども

0:09:08.310,0:09:16.953
この中には0から1000 xですね
yは0から500のピクセル座標が入っています

0:09:16.978,0:09:23.463
次のですねこの黄色くなっているところ
gl_FragCoord.xy * 2.0 - uResolution

0:09:23.488,0:09:29.482
これなんですけれども
これをすることによって範囲を指定することができるんですね

0:09:29.506,0:09:35.179
-uResolutionからuResolutionと
範囲を指定します

0:09:35.204,0:09:43.198
xの場合は-1000から1000
yの場合は-500から500という値がここに入ってきます

0:09:44.790,0:09:50.710
最後にmin(uResolution.x, uResolution.y)
というやつなんですけども

0:09:50.710,0:09:57.699
minという関数は
どちらかの小さい方を返すということになっています

0:09:57.699,0:10:05.070
ここではmin(1000, 500)なので
必ず500が返ってくるということになっています

0:10:05.070,0:10:13.556
この1から3のところをx とyに分けて
さらにわかりやすいように具体的な数字を入れて考えていきます

0:10:14.630,0:10:20.646
まずですねこのgl_FragCoord.x
には0から1000という数字が入りますね

0:10:20.671,0:10:32.110
なので0を入れたときに0 * 2.0-1000ということなので
左側には-1000が入ります

0:10:32.110,0:10:41.560
右側には必ず500という数字が入ってくると
1000と500を比較して必ず500という数字が入るようになります

0:10:41.560,0:10:49.210
なのでxが0の時は-2.0が返ってくる
ということになりますね

0:10:50.850,0:10:55.719
今度は最大値1000がここに入った時には

0:10:55.744,0:11:04.803
1000 * 2.0-1000つまり2000-1000なので
ここには1000という数字が入っています

0:11:04.827,0:11:10.320
で右側は500と
なのでここは1000/500で2.0が入ってきます

0:11:10.320,0:11:14.540
今度はy方向なんですけれども

0:11:14.600,0:11:25.160
yが0の時には0 * 2.0-500
つまり-500が左側に入ってきて

0:11:25.160,0:11:33.649
右側には500が入ってきます
-500/500で-1.0という数値が入ってきます

0:11:33.649,0:11:43.450
で今度はyに500の値が入った時なんですけども
500*2.0-500で500が入ってきて

0:11:43.450,0:11:48.086
minの方は500なので1.0という答えが返ってきます

0:11:48.111,0:11:59.848
で結果左下が(-2.0, -1.0) 右上が(2.0, 1.0)
という範囲で座標が作られたということになります

0:11:59.873,0:12:03.025
これをコードで書いていきます

0:12:03.050,0:12:06.805
これを1000と500にしておきます

0:12:06.830,0:12:13.270
こうですね
先ほどのpが…

0:12:15.527,0:12:18.449
これをコピペしました
ここにこう入ると

0:12:18.473,0:12:23.693
今エラーが出ているのは解像度がちゃんと入っていないからなので

0:12:23.718,0:12:28.180
ここにuniformとして入れていきます

0:12:31.189,0:12:38.588
こうですねこれで

0:12:38.613,0:12:43.230
1000と500が入りました

0:12:43.230,0:12:50.404
今中心点がちょっとずれていますが
centerの0.5のずれが必要なくなるわけですね

0:12:50.429,0:12:57.554
なのでこれは0.0にして
こうすると真ん中に寄りましたね

0:12:57.579,0:13:02.151
これちょっとサイズが小さくなったので
これを2にしてもいいかもしれません

0:13:02.176,0:13:07.678
これが何が起こっているかと言うと
またuvでちょっと見てみたいと思います

0:13:09.184,0:13:20.727
color.rgb = vec3(p, 0.0);

0:13:20.752,0:13:25.059
こうですね
これをちょっと大きく見てみたいと思います

0:13:25.084,0:13:31.828
今までの例ですと
一番左下に(0, 0)ポイントがあって

0:13:31.853,0:13:37.330
これがあったと思うんですけど
こういう風になって真ん中に(0, 0)があるようになってるんですね

0:13:37.355,0:13:41.074
これをTOP Toで見てみると

0:13:41.099,0:13:48.703
Top ToのRowこの範囲ですよね
この範囲を見てみると-2から2を取っているということになります

0:13:49.580,0:13:56.363
なので-1から1の範囲は真ん中のここなんですね
-1から1の範囲になっています

0:13:56.388,0:13:59.568
1回このuvを戻します

0:13:59.593,0:14:06.279
これがどういうことをやっているかと言うと
Composite TOPのFit Verticalと同じ挙動になります

0:14:06.304,0:14:08.517
ちょっとやってみましょう

0:14:08.542,0:14:14.478
Circleがあって

0:14:17.544,0:14:25.405
CircleとConstant
これのサイズを1000と500にしてみます

0:14:25.430,0:14:33.685
こうですね これでAlpha0
compがあると

0:14:33.710,0:14:39.439
この2つをつなげて Addでいいかな
こういう感じですね

0:14:39.464,0:14:45.880
これが先ほどの正規化前の状態なので
横にビヨンと伸びちゃってるんですけども

0:14:45.905,0:14:53.501
これをTransformのFit Verticalこれですね
これを選ぶとこういう風になると

0:14:53.526,0:15:01.071
縦の辺に合わせて
横も正規化しているということになります

0:15:01.096,0:15:08.838
まさにこれと同じことを
今回このGLSLでもやっているということになります

0:15:15.449,0:15:19.223
これで円を描くことができました

0:15:19.248,0:15:21.590
今回はここまでとなります

0:15:21.615,0:15:27.368
TDSWでは毎月2回程度
週末にライブ配信ワークショップを行っています

0:15:27.393,0:15:31.781
チケットはPeatixやEventbriteからお求めいただけます

0:15:31.806,0:15:37.509
またPatreonも利用しています
現在こちらの3つのプランがあります

0:15:37.534,0:15:42.104
これらのリンクは動画の概要欄にありますので
よかったらチェックしてみてください

0:15:42.128,0:15:44.294
それではご視聴ありがとうございました

0:15:44.319,0:15:48.746
気に入って頂けたら
グッドボタン、チャンネル登録をよろしくお願いいたします

0:15:48.771,0:15:50.278
ではまた

0:15:50.974,0:16:06.464
[音楽]